---
title: "【TypeScript実務対策】@typescript-eslint/no-explicit-any を「無効化せずに」解決する戦略"
emoji: "🚫"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["typescript","any"]
published: false
---

## はじめに

TypeScriptを使っていると、誰もが一度は目にするエラーがあります。

> Error: Unexpected any. Specify a different type.  @typescript-eslint/no-explicit-any

型安全を保つためのルールですが、現場では「消したい」「無効化したい」と思う瞬間も多いでしょう。この記事では、このルールを無効化せずに、実務的に共存する方法を紹介します。


## 対象者
* ESLintとTypeScriptを用いて開発しているエンジニア
* any問題や型定義で悩んでいる方
* ビルドエラーや型崩れを経験した方


## 1. 基礎知識：@typescript-eslint/no-explicit-any

### なぜこのルールが重要なのか

TypeScriptの強みは「静的型付けによる安心感」です。しかし、`any`を使いすぎるとその恩恵が失われ、最終的にJavaScriptと変わらなくなってしまいます。そのため、`no-explicit-any`ルールは「型安全を守るための防波堤」として非常に重要な役割を果たします。

### ルールの設定方法

`.eslintrc.json`での基本設定：

```json
{
  "rules": {
    "@typescript-eslint/no-explicit-any": "error"
  }
}
```

### エラーが発生するケース

```typescript
// エラー：明示的なanyの使用
function processData(data: any) {
  return data.someProperty;
}

// エラー：配列でのany使用
const items: any[] = [];

// エラー：ジェネリクスでのany使用
const cache = new Map<string, any>();
```

## 2. 無効化の落とし穴と推奨アプローチ

### 🚨 無効化がもたらすリスク

プロジェクト全体でルールを無効化した場合の影響

```json
// ⚠️ 推奨されない設定
{
  "rules": {
    "@typescript-eslint/no-explicit-any": "off"
  }
}
```
:::message
**結果として起こる問題点**
- 型推論の恩恵が失われる
- ランタイムエラーが増加
- リファクタリング時の安全性が低下
- コードレビューでの型チェックが困難に
:::

### 推奨アプローチ：段階的な対応

```typescript
// 一時的な例外として、意図を明確にコメント
// eslint-disable-next-line @typescript-eslint/no-explicit-any -- 外部ライブラリの型定義待ち
function handleLegacyLibrary(data: any) {
  // 処理内容
}
```

## 3. 代替案

### 解決策1：`unknown`型で安全に受け取る

`unknown`は「型安全なany」として機能します

```typescript
// 推奨：unknown型の活用
async function fetchApiData(url: string): Promise<unknown> {
  const response = await fetch(url);
  return response.json();
}

// 使用時は型ガードやアサーションが必要
async function getUserData() {
  const data = await fetchApiData('/api/user');
  
  // 型ガードによる安全な型絞り込み
  if (isUserData(data)) {
    console.log(data.name); // 型安全にアクセス可能
  }
}

// 型ガード関数
function isUserData(data: unknown): data is { name: string; id: number } {
  return (
    typeof data === 'object' &&
    data !== null &&
    'name' in data &&
    'id' in data
  );
}
```

### 解決策2：`Record`型で構造を定義

オブジェクト型が確実な場合

```typescript
// キーと値の型を明確にする
type ApiResponse = Record<string, unknown>;

function processApiResponse(response: ApiResponse) {
  // 各プロパティはunknownなので、使用時に型チェックが必要
  const status = response['status'];
  if (typeof status === 'string') {
    console.log(status.toUpperCase());
  }
}
```

### 解決策3：ジェネリクスで柔軟性を確保

```typescript
// ジェネリクスで型安全と柔軟性を両立
class ApiClient {
  async get<T = unknown>(url: string): Promise<T> {
    const response = await fetch(url);
    return response.json() as T;
  }
}

// 使用例
interface User {
  id: number;
  name: string;
}

const client = new ApiClient();
const user = await client.get<User>('/api/user/1');
console.log(user.name); // 型安全にアクセス
```

## 4. ZodやPrismaと組み合わせた型安全戦略

### ライブラリ概要

* **Zod**: データのバリデーションと型推論を同時に行うライブラリ
* **Prisma**: 型安全なORMで、DBスキーマから型を自動生成

これらを組み合わせることで、データの型定義を一元化できます。
こうすることで、`any`の登場余地が消え、API層とDB層の型整合性も維持されます。

## 5. 段階的導入戦略

すべての`any`を禁止するのは非現実的です。以下のように段階的に厳格化するのがおすすめです。

### フェーズ別設定

```json
// .eslintrc.json
{
  "overrides": [
    {
      "files": ["src/legacy/**/*.ts"],
      "rules": {
        "@typescript-eslint/no-explicit-any": "warn"
      }
    },
    {
      "files": ["src/new/**/*.ts"],
      "rules": {
        "@typescript-eslint/no-explicit-any": "error"
      }
    }
  ]
}
```

## まとめ

`@typescript-eslint/no-explicit-any`は、TypeScriptプロジェクトの型安全性を守る重要な防波堤です。
型安全性は適切なツールと戦略により、開発速度を維持しながら技術的負債を削減できます。

**アプローチ例**
1. **unknown型**：不明な型を安全に扱う
2. **ジェネリクス**：柔軟性と型安全性の両立
3. **Zod**：ランタイム検証による確実な型安全性
4. **段階的導入**：チームの負担を最小化


:::message
**ポイント**
- 新規ファイルでは`any`を使わない
- 既存の`any`に「なぜ必要か」をコメントで残す
- チームでZodの導入を検討する
:::


---

## 参考リンク

- [TypeScript ESLint - no-explicit-any](https://typescript-eslint.io/rules/no-explicit-any/)
- [Zod Documentation](https://zod.dev/)
- [Prisma TypeScript Client](https://www.prisma.io/docs/concepts/components/prisma-client/working-with-prismaclient/generating-prisma-client)


---

## おわりに

「no-explicit-any」に対しては、anyを禁止することが目的ではなく、「型安全を保ちつつ、開発を止めない」ことが本質です。Zod・Prisma・ジェネリクス・unknownなどをうまく組み合わせれば、`any`を“封印”することなく、安全に使いこなせます。
型安全なTypeScriptプロジェクトの構築に、この記事が一助となれば幸いです。

---

## 株式会社ONE WEDGE
【Serverlessで世の中をもっと楽しく】
ONE WEDGEはServerlessシステム開発を中核技術としてWeb系システム開発、AWS/GCPを利用した業務システム・サービス開発、PWAを用いたモバイル開発、Alexaスキル開発など、元気と技術力を武器にお客様に真摯に向き合う価値創造企業です。
https://onewedge.co.jp/