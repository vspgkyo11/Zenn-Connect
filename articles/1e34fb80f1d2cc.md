---
title: "【Laravel】はじめてのWebサーバー構成アップグレードガイド"
emoji: "🛡️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Webサーバー", "Laravel", "Linux", "運用"]
published: true
---

## はじめに

稼働中のWebサーバーにおけるフレームワークやミドルウェアのバージョンアップは、システム運用において避けて通れないタスクです。
本記事では、Laravelアプリケーションを稼働させているWebサーバーを更新する際の、基本的な手順と依存関係の考え方について解説します。

## 対象者

* Laravelアプリケーションの運用保守を担当しているエンジニア
* ミドルウェアのバージョンアップやOS更新をしたい方
* 現在のサーバー環境を正確に把握したい方

## 依存関係と更新の原則

更新作業において最も重要なのは、各コンポーネントの依存関係を正しく把握することです。
一般的なLaravelアプリケーションの構成は、以下のようなレイヤー構造になっています。

1. **アプリケーション層**: Laravelプロジェクトのソースコード
2. **フレームワーク層**: Laravel本体
3. **ミドルウェア層**: PHP, Nginx, MySQL, Redis
4. **インフラ層**: OS (Linux), Dockerコンテナ

### 原則：依存の方向性

依存関係は「上位レイヤーが下位レイヤーに依存する」という構造を持ちます。
Laravel（フレームワーク層）は特定のPHPバージョン（ミドルウェア層）に依存し、PHPはOS（インフラ層）上のライブラリに依存します。

したがって、更新計画は「上位レイヤーから要件を確認し、下位レイヤーから更新を確定させる」のが鉄則です。

## 更新ワークフロー

安全なアップグレードを実施するための基本的な手順を以下に示します。

### Step 0: 前提環境の確認

作業を開始する前に、現状のサーバー環境を正確に把握します。
特に自分が管理していないサーバーの場合、「Dockerで動いているのか、OSに直接インストールされているのか」の判別が最優先です。

#### 環境判別コマンド
プロジェクトのルートディレクトリで以下を確認します。

```bash
# docker-compose.yml が存在するか確認
ls -l docker-compose.yml compose.yml

# プロセスレベルでDockerが動いているか確認
docker ps
```

ファイルが存在し、Dockerプロセスも見えている場合は、Docker環境として扱います。

#### 基本情報の収集
OSのバージョンやアーキテクチャは、インストールすべきパッケージの選定の判断軸となります。

```bash
# OSバージョンの確認
cat /etc/os-release

# カーネルとアーキテクチャの確認 (x86_64 / aarch64)
uname -a

# ディスク空き容量の確認 (必須)
df -h
```

また、現在のミドルウェアバージョンも記録しておきます。

```bash
php -v
composer --version
mysql --version
```

※ Docker環境の場合は、ホストOSではなく、`docker compose exec app php -v` のようにコンテナ内部で実行して確認してください。

#### Webサーバーの特定 (Nginx / Apache)
サーバーがNginxなのかApacheなのか不明な場合は、プロセスまたはレスポンスヘッダーで確認します。

```bash
# プロセスから確認
ps aux | grep -E 'nginx|apache|httpd'

# レスポンスヘッダーから確認 (Serverヘッダーを見る)
curl -I localhost
```

### Step 1: 要件定義

更新のゴール（例：Laravel 11 → 12）を明確にし、公式ドキュメントに基づいて必要なサーバー要件をリストアップします。
[Laravel Server Requirements](https://laravel.com/docs/12.x/deployment#server-requirements)

* **PHP バージョン**: 最低要件バージョン
* **拡張機能**: 必要なPHP拡張モジュール（BCMath, Ctype, Fileinfoなど）
* **データベース**: 対応するデータベースのバージョン

この段階で、現在の環境とのギャップを特定します。

### Step 2: バックアップとロールバック計画

「バックアップを取る」だけでなく、「失敗した時にどう戻すか（リストア手順）」まで確立してから作業に入ります。

* **コード**: Gitによる管理。作業前にタグを打つか、作業用ブランチを作成します。
* **データベース**: `mysqldump` 等によるダンプ取得。
    * リストア手順: `mysql -u user -p dbname < backup.sql` が通ることを確認。
* **システム**: VPSのスナップショットやAMIの作成。これが確実なロールバック手段となります。

:::message
**注意事項**
ステージング環境での検証なしに本番環境でこれらを実施するのはとてもリスクが高いです。可能な限り、本番と同等の検証環境でリハーサルを行うことを推奨します。
:::

### Step 3: メンテナンスモードへの切り替え

データ整合性を保つため、更新作業中はユーザーからのアクセスを遮断します。
Laravel標準のメンテナンスモードを使用します。

```bash
# メンテナンスモード有効化（シークレットトークンを設定推奨）
php artisan down --secret="my_secret_token"

# ※ 解除コマンド（作業完了後に実行）
php artisan up
```

### Step 4: ミドルウェア層の更新

Step 1で特定した要件に基づき、下位レイヤーから更新を行います。

**Docker環境以外の場合**:
パッケージマネージャー（apt, yum等）を使用して、PHPやミドルウェアを更新します。

```bash
# 例: UbuntuでのPHP更新フローの一部
sudo apt update
sudo apt install php8.2 php8.2-fpm php8.2-mysql ...
```

**Docker環境の場合**:
`Dockerfile` のベースイメージタグを変更し、イメージを再ビルドします。

```dockerfile
# Before
FROM php:8.2-fpm

# After
FROM php:8.3-fpm
```

ローカル環境でビルドと動作確認を行えるのがDocker構成の大きな利点です。

### Step 5: アプリケーション層の更新

土台となる環境が整った後、アプリケーションの更新を行います。
`composer.json` を編集し、依存パッケージを更新します。

```bash
composer update
```

この段階で、破壊的変更によるエラーが発生する可能性があります。エラーログを確認し、アプリケーションコードを修正してください。
また、Laravel本体だけでなく、依存しているサードパーティ製ライブラリも新しいPHPバージョンに対応しているか確認が必要です。

### Step 6: 反映と動作確認

最後に、変更を適用し、正常に動作していることを確認します。
キャッシュクリアとエラーが出ていないかをログで確認します。

```bash
# 1. 変更の適用とキャッシュクリア
php artisan migrate
php artisan optimize:clear

# 2. ログの監視
tail -f storage/logs/laravel.log
```

この状態でブラウザからWebサイトにアクセスし、画面が正しく表示されるか、ログにエラー（`ERROR` や `Stack trace`）が流れてこないかを確認して完了です。

## おわりに

私自身、はじめてWebサーバー上での更新作業は、どの順で進めるべきか、どのコマンドを叩くべきか、そもそもコマンドの意味はなんなのか、などわからないことが多くかなり苦戦しました。
しかし、サーバーの更新作業は、単なるメンテナンスではなく、システムの構造を深く理解する絶好の機会でもあります。適切な準備とバックアップさえあれば、システム全体の整合性を保ちながら安全に更新することができます。本記事が、安全なアップグレードの一助となれば幸いです。

---

## 株式会社ONE WEDGE
【Serverlessで世の中をもっと楽しく】
ONE WEDGEはServerlessシステム開発を中核技術としてWeb系システム開発、AWS/GCPを利用した業務システム・サービス開発、PWAを用いたモバイル開発、Alexaスキル開発など、元気と技術力を武器にお客様に真摯に向き合う価値創造企業です。
https://onewedge.co.jp/
